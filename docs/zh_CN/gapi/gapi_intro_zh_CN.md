# OpenCV Graph API (G-API) 简介 {#openvino_docs_gapi_gapi_intro_zh_CN}

@sphinxdirective

.. toctree::
   :maxdepth: 1
   :hidden:

   openvino_docs_gapi_kernel_api
   openvino_docs_gapi_face_beautification
   openvino_docs_gapi_gapi_face_analytics_pipeline

@endsphinxdirective

OpenCV Graph API (G-API) 是一个旨在以快捷、可移植的方式处理常规图像和视频的 OpenCV 模块。G-API 是 OpenCV 中的一个特殊模块，与其他大多数主要模块不同，此模块充当框架，而不是某种特定的 CV 算法。

G-API 被定位为面向计算机视觉的下一级优化促进工具，其侧重点不是特定 CV 函数，而是整体算法优化。

G-API 提供了定义 CV 操作的方法，G-API 可用于构造图形（以表达式的形式），并最终为特定后端实现和运行这些操作。

G-API 背后的理念是：如果可以用特定的嵌入式语言（当前为 C++）来表示算法，该框架就会理解其意思，并自动对整个算法应用各种优化。将根据哪些[内核](../../gapi/kernel_api.md)和[后端](https://docs.opencv.org/4.5.0/dc/d1c/group__gapi__std__backends.html)参与图形编译过程来选择特定优化，例如，可以通过 OpenCL 后端将图形分载到 GPU，或通过 Fluid 后端优化内存消耗。内核、后端及其设置是图形编译的参数。因此，图形本身并不依赖于任何特定于平台的细节，而且可以轻松移植。

> **NOTE**: Graph API (G-API) 在最近的重要 OpenCV 4.0 版本中推出，当前正处于积极开发阶段。目前该 API 尚不稳定，将来可能会做出细微更改，但不会影响兼容性。

## G-API 概念

* 通过对数据对象应用操作来构建*图形*。
   * API 本身没有“图形”，而是基于表达式。
* *数据对象*不保存实际数据，仅捕获依赖项。
* *操作*会使用并生成数据对象。
* 图形通过使用数据对象来指定其边界而进行定义：
   * 哪些数据对象是图形的输入？
   * 其输出是什么？

以下各段介绍 G-API 编程模型和开发工作流程。

## 编程模型
使用 G-API 可以轻松构建图形。实际上，在该 API 中并未公开任何图形概念。因此，用户不需要针对“节点”和“边缘”执行操作。相反，图形通过表达式以“功能”方式隐式构造。基于表达式的图形通过两个主要概念来构建：*[操作](../../gapi/kernel_api.md)*和*[数据对象](https://docs.opencv.org/4.2.0/db/df1/group__gapi__data__objects.html)*。

在 G-API 中，每个图形都以数据对象作为起点和终结点；数据对象被传递给操作，后者生成（“返回”）结果 - 新的数据对象，然后将其传递给其他操作，依此类推。您可以声明自己的操作，但 G-API 不会以任何方式区分用户定义操作与它自己的预定义操作。

定义图形后，就需要对其进行编译以便执行。在编译过程中，G-API 会了解图形的外观，哪些内核可用于在图形中执行操作，如何管理异构性以及如何优化执行路径。图形编译结果是一个所谓的“已编译”对象。此对象会封装图形内部的执行序列，并对真实的图像数据执行操作。您可以使用各种[编译参数](https://docs.opencv.org/4.5.0/dc/d1c/group__gapi__std__backends.html)设置编译过程。后端会将它们的一些选项作为这些参数予以公开；此外，实际的内核和深度学习网络设置也会以这种方式传递到框架。

G-API 支持两种执行模式的图形编译：*常规*和*流式*，并因此生成不同类型的已编译对象。
* <strong>常规</strong>已编译对象用类 GCompiled 表示，它遵循类函子语义并具有一个过载 operator()。如果针对给定输入数据执行调用，GCompiled 函子会阻止当前线程并立即处理数据 - 就像常规 C++ 函数一样。默认情况下，G-API 会尝试优化执行时间，以缩短这种编译模式的延迟。
* 从 OpenCV 4.2 开始，G-API 还可以生成 GStreamingCompiled 对象。该对象更适合异步管道执行模型。这种编译模式称为**流模式**，并且 G-API 会尝试通过实现上述管道技术来优化总吞吐量。我们将在示例中使用这两种模式。

常规模式的整个过程如下图所示：

![G-API 编程模型](../../img/gapi_programming_model.png)

图形通过操作来构建。因此，定义操作 (**0**) 是基本的前提条件；构造的表达式图形 (**1**) 构成一个 `cv::GComputation` 对象；实现操作的内核 (**2**) 是图形编译 (**3**) 的基本要求；实际执行 (**4**) 由 `cv::GCompiled` 对象处理。该对象将接受输入并生成输出数据。

## 开发工作流程
组织 G-API 开发工作流程的方式之一如下图所示：

![G-API 开发工作流程](../../img/gapi_development_workflow.png)

基本上，它由上一章介绍的编程模型衍生而来。您首先考虑某个算法或数据流 (**0**)，将其映射到图形模型 (**1**)，然后确定您需要执行哪些操作 (**2**) 来构造此图形。G-API 中可能已存在或缺失这些操作，在后一种情况下，我们会将缺失的操作作为内核来实现 (**3**)。然后决定哪种执行模型更适合我们的情况，将内核和深度学习网络作为参数传递到编译过程 (**4**)，并最终切换到执行 (**5**)。该过程具有迭代性。因此，如果希望根据执行结果更改任何内容，请返回步骤 (**0**) 或 (**1**)（虚线）。






