# type: ignore
from __future__ import annotations
import openvino._pyopenvino
import typing
"""
openvino.properties.intel_npu submodule that simulates ov::intel_npu
"""
__all__: list[str] = ['bypass_umd_caching', 'compilation_mode_params', 'compiler_dynamic_quantization', 'compiler_version', 'defer_weights_load', 'device_alloc_mem_size', 'device_total_mem_size', 'driver_version', 'max_tiles', 'qdq_optimization', 'qdq_optimization_aggressive', 'run_inferences_sequentially', 'tiles', 'turbo', 'platform', 'CompilerType', 'compiler_type']
class CompilerType:
    """
    Members:

      PLUGIN

      DRIVER
    """
    PLUGIN: typing.ClassVar[CompilerType]  # value = <CompilerType.PLUGIN: 0>
    DRIVER: typing.ClassVar[CompilerType]  # value = <CompilerType.DRIVER: 1>
    __members__: typing.ClassVar[dict[str, CompilerType]]  # value = {'PLUGIN': <CompilerType.PLUGIN: 0>, 'DRIVER': <CompilerType.DRIVER: 1>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __ge__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __gt__(self, other: typing.Any) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: typing.SupportsInt) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __le__(self, other: typing.Any) -> bool:
        ...
    def __lt__(self, other: typing.Any) -> bool:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: typing.SupportsInt) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
@typing.overload
def bypass_umd_caching() -> str:
    ...
@typing.overload
def bypass_umd_caching(arg0: bool) -> tuple[str, openvino._pyopenvino.OVAny]:
    ...
@typing.overload
def compilation_mode_params() -> str:
    ...
@typing.overload
def compilation_mode_params(arg0: str) -> tuple[str, openvino._pyopenvino.OVAny]:
    ...
@typing.overload
def compiler_dynamic_quantization() -> str:
    ...
@typing.overload
def compiler_dynamic_quantization(arg0: bool) -> tuple[str, openvino._pyopenvino.OVAny]:
    ...
def compiler_version() -> str:
    ...
@typing.overload
def defer_weights_load() -> str:
    ...
@typing.overload
def defer_weights_load(arg0: bool) -> tuple[str, openvino._pyopenvino.OVAny]:
    ...
def device_alloc_mem_size() -> str:
    ...
def device_total_mem_size() -> str:
    ...
def driver_version() -> str:
    ...
@typing.overload
def max_tiles() -> str:
    ...
@typing.overload
def max_tiles(arg0: typing.SupportsInt) -> tuple[str, openvino._pyopenvino.OVAny]:
    ...
@typing.overload
def qdq_optimization() -> str:
    ...
@typing.overload
def qdq_optimization(arg0: bool) -> tuple[str, openvino._pyopenvino.OVAny]:
    ...
@typing.overload
def qdq_optimization_aggressive() -> str:
    ...
@typing.overload
def qdq_optimization_aggressive(arg0: bool) -> tuple[str, openvino._pyopenvino.OVAny]:
    ...
@typing.overload
def run_inferences_sequentially() -> str:
    ...
@typing.overload
def run_inferences_sequentially(arg0: bool) -> tuple[str, openvino._pyopenvino.OVAny]:
    ...
@typing.overload
def tiles() -> str:
    ...
@typing.overload
def tiles(arg0: typing.SupportsInt) -> tuple[str, openvino._pyopenvino.OVAny]:
    ...
@typing.overload
def turbo() -> str:
    ...
@typing.overload
def turbo(arg0: bool) -> tuple[str, openvino._pyopenvino.OVAny]:
    ...
@typing.overload
def platform() -> str:
    ...
@typing.overload
def platform(arg0: str) -> tuple[str, openvino._pyopenvino.OVAny]:
    ...
@typing.overload
def compiler_type(arg0: CompilerType) -> tuple[str, openvino._pyopenvino.OVAny]:
    ...
