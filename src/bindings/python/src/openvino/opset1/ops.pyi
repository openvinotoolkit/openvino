import numpy as np
import openvino._pyopenvino.op
import typing
from functools import partial as partial
from openvino._pyopenvino import Node as Node, PartialShape as PartialShape, Type as Type
from openvino._pyopenvino.op import Constant as Constant, Parameter as Parameter, tensor_iterator as tensor_iterator
from openvino.package_utils import deprecated as deprecated
from openvino.utils.decorators import binary_op as binary_op, nameable_op as nameable_op, unary_op as unary_op
from openvino.utils.input_validation import check_valid_attributes as check_valid_attributes, is_non_negative_value as is_non_negative_value, is_positive_value as is_positive_value
from openvino.utils.node_factory import NodeFactory as NodeFactory
from openvino.utils.types import as_node as as_node, as_nodes as as_nodes, get_dtype as get_dtype, get_element_type as get_element_type, get_element_type_str as get_element_type_str, make_constant_node as make_constant_node
from typing import get_args as get_args

def absolute(input_value, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def acos(input_value, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def add(left, right, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def asin(input_value, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def atan(input_value, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def avg_pool(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def batch_norm_inference(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def binary_convolution(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def broadcast(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def ceiling(input_value, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def clamp(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def concat(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def constant(*args, **kwargs) -> openvino._pyopenvino.op.Constant: ...
def convert(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def convert_like(left, right, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def convolution(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def convolution_backprop_data(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def cos(input_value, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def cosh(input_value, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def ctc_greedy_decoder(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def deformable_convolution(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def deformable_psroi_pooling(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def depth_to_space(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def detection_output(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def divide(left, right, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def elu(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def equal(left, right, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def erf(input_value, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def exp(input_value, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def fake_quantize(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def floor(input_value, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def floor_mod(left, right, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def gather(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def gather_tree(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def greater(left, right, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def greater_equal(left, right, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def grn(data: openvino._pyopenvino.Node, bias: float, name: typing.Optional[str] = ...) -> openvino._pyopenvino.Node: ...
def group_convolution(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def group_convolution_backprop_data(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def hard_sigmoid(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def interpolate(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def less(left, right, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def less_equal(left, right, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def log(input_value, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def logical_and(left, right, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def logical_not(input_value, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def logical_or(left, right, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def logical_xor(left, right, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def lrn(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def lstm_cell(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def matmul(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def max_pool(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def maximum(left, right, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def minimum(left, right, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def mod(left, right, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def multiply(left, right, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def negative(input_value, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def non_max_suppression(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def normalize_l2(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def not_equal(left, right, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def one_hot(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def pad(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def parameter(*args, **kwargs) -> openvino._pyopenvino.op.Parameter: ...
def power(left, right, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def prelu(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def prior_box(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def prior_box_clustered(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def proposal(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def psroi_pooling(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def range(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def reduce_logical_and(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def reduce_logical_or(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def reduce_max(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def reduce_mean(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def reduce_min(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def reduce_prod(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def reduce_sum(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def region_yolo(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def relu(input_value, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def reshape(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def result(input_value, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def reverse_sequence(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def select(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def selu(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def shape_of(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def sigmoid(input_value, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def sign(input_value, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def sin(input_value, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def sinh(input_value, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def softmax(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def space_to_depth(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def split(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def sqrt(input_value, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def squared_difference(left, right, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def squeeze(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def strided_slice(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def subtract(left, right, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def tan(input_value, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def tanh(input_value, *args, **kwargs) -> openvino._pyopenvino.Node: ...
def tile(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def topk(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def transpose(*args, **kwargs) -> openvino._pyopenvino.Node: ...
def unsqueeze(data: typing.Union[openvino._pyopenvino.Node, int, float, numpy.ndarray], axes: typing.Union[openvino._pyopenvino.Node, int, float, numpy.ndarray], name: typing.Optional[str] = ...) -> openvino._pyopenvino.Node: ...
def variadic_split(*args, **kwargs) -> openvino._pyopenvino.Node: ...

NodeInput: typing._UnionGenericAlias
NumericData: typing._UnionGenericAlias
NumericType: typing._UnionGenericAlias
ScalarData: typing._UnionGenericAlias
TensorShape: typing._GenericAlias
